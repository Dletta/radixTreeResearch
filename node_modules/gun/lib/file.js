/* Modified File Adapter to write in batches, write one file per node that is passed in per put,
and to start with readSync for gets */

/* Will it scale? It won't work in browser, where Radix could, this is one thing to try with panic once ready */

var Gun = require('../gun'),
fs = require('fs');

Gun.on('opt', function(ctx){
	this.to.next(ctx);
	var opt = ctx.opt;
	if(ctx.once){ return }
	if(false === opt.localStorage){ return }
	if(process.env.AWS_S3_BUCKET){ return }
	/* Create Folder if it does not exist */
	opt.file = String(opt.file || './data/');
	var exist = fs.existsSync(opt.file);
	if(false === exist){ fs.mkdirSync(opt.file); }
	var graph = ctx.graph, acks = {}, count = 0, to;
	/* Load file from disk and create cache named disk with each node */
	var disk = Object.create(null)
	disk = Gun.obj.ify(/*(fs.existsSync || require('path').existsSync)(opt.file)?
		fs.readFileSync(opt.file).toString()
	: */null) || {};
	console.dir(Object.keys(disk));

	Gun.log.once(
		'file-Dletta Version',
		'WARNING! This `file.js` module for gun is ' +
		'intended for local development testing only!'
	);

	ctx.on('put', function(at){
		this.to.next(at);
		Gun.graph.is(at.put, null, map);
		console.dir(Object.keys(disk));
		if(!at['@']){ acks[at['#']] = true; } // only ack non-acks.
		count += 1;
		if(count >= (opt.batch || 5)){
			return flush();
		}
		if(to){ return }
		to = setTimeout(flush, opt.wait || 1);
	});

	ctx.on('get', function(at){
		this.to.next(at);
		var lex = at.get, soul, data, opt, u;
		//setTimeout(function(){
		if(!lex || !(soul = lex['#'])){ return }
		//if(0 >= at.cap){ return }
		if(Gun.obj.is(soul)){ return match(at) }
		var field = lex['.'];
		data = disk[soul] || u;
		console.dir(Object.keys(disk));
		if(data && field){
			data = Gun.state.to(data, field);
		}
		ctx.on('in', {'@': at['#'], put: Gun.graph.node(data)});
		//},11);
	});

	var map = function(val, key, node, soul){
		disk[soul] = Gun.state.to(node, key, disk[soul]);
	}

	var wait, u;
	var flush = function(){
		if(wait){ return }
		clearTimeout(to);
		to = false;
		var ack = acks;
		acks = {};
		console.log('Flushing');
		console.dir(Object.keys(disk));
		fs.writeFile(opt.file, JSON.stringify(disk), function(err, ok){
			wait = false;
			var tmp = count;
			count = 0;
			Gun.obj.map(ack, function(yes, id){
				ctx.on('in', {
					'@': id,
					err: err,
					ok: err? u : 1
				});
			});
			if(1 < tmp){ flush() }
		});
	}

	function match(at){
		var rgx = at.get['#'], has = at.get['.'];
		Gun.obj.map(disk, function(node, soul, put){
			if(!Gun.text.match(soul, rgx)){ return }
			if(has){ node = Gun.state.to(node, has) }
			(put = {})[soul] = node;
			ctx.on('in', {put: put, '@': at['#']});
		});
	}
});
